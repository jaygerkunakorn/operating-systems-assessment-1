use nix::sys::wait::{waitpid, WaitPidFlag, WaitStatus};
use nix::unistd::{close, dup2, execvp, fork, pipe, ForkResult, Pid};
use std::env;
use std::ffi::CString;
use std::fs::File;
use std::io::{self, Write};
use std::os::fd::{AsRawFd, OwnedFd};
use std::path::PathBuf;
use std::process::exit;

/// Print prompt with current working directory.
fn print_prompt() {
    match env::current_dir() {
        Ok(d) => print!("vssh:{}$ ", d.display()),
        Err(_) => print!("vssh:<?>$ "),
    }
    let _ = io::stdout().flush();
}

/// Tokenize into words and single-char operators: | < > &
fn tokenize(line: &str) -> Vec<String> {
    let mut out = Vec::new();
    let mut buf = String::new();
    for ch in line.chars() {
        match ch {
            '|' | '<' | '>' | '&' => {
                if !buf.is_empty() {
                    out.push(std::mem::take(&mut buf));
                }
                out.push(ch.to_string());
            }
            c if c.is_whitespace() => {
                if !buf.is_empty() {
                    out.push(std::mem::take(&mut buf));
                }
            }
            c => buf.push(c),
        }
    }
    if !buf.is_empty() {
        out.push(buf);
    }
    out
}

#[derive(Clone, Debug)]
struct Stage {
    argv: Vec<CString>,
    in_redir: Option<String>,
    out_redir: Option<String>,
}

/// Parse a line into pipeline stages + background flag.
/// `< file` only allowed on first stage; `> file` only on last stage.
fn parse_pipeline(line: &str) -> Result<(Vec<Stage>, bool), String> {
    let mut toks = tokenize(line);
    if toks.is_empty() {
        return Err("empty command".into());
    }

    // check for trailing '&'
    let mut background = false;
    if toks.last().map(|s| s.as_str()) == Some("&") {
        background = true;
        toks.pop();
        if toks.is_empty() {
            return Err("empty command".into());
        }
        if toks.last().map(|s| s.as_str()) == Some("&") {
            return Err("multiple '&' not supported".into());
        }
    }

    // split by '|'
    let mut segs: Vec<Vec<String>> = Vec::new();
    {
        let mut cur = Vec::new();
        for t in toks {
            if t == "|" {
                if cur.is_empty() {
                    return Err("syntax error: '|' without command".into());
                }
                segs.push(std::mem::take(&mut cur));
            } else {
                cur.push(t);
            }
        }
        if cur.is_empty() {
            return Err("syntax error: trailing '|'".into());
        }
        segs.push(cur);
    }

    let n = segs.len();
    let mut stages = Vec::with_capacity(n);

    for (i, seg) in segs.into_iter().enumerate() {
        let mut argv: Vec<CString> = Vec::new();
        let mut in_redir: Option<String> = None;
        let mut out_redir: Option<String> = None;

        let mut j = 0;
        while j < seg.len() {
            match seg[j].as_str() {
                "<" => {
                    if i != 0 {
                        return Err("'<': only allowed on first command".into());
                    }
                    if j + 1 >= seg.len() {
                        return Err("expected filename after '<'".into());
                    }
                    if in_redir.is_some() {
                        return Err("duplicate input redirection".into());
                    }
                    in_redir = Some(seg[j + 1].clone());
                    j += 2;
                }
                ">" => {
                    if i != n - 1 {
                        return Err("'>' : only allowed on last command".into());
                    }
                    if j + 1 >= seg.len() {
                        return Err("expected filename after '>'".into());
                    }
                    if out_redir.is_some() {
                        return Err("duplicate output redirection".into());
                    }
                    out_redir = Some(seg[j + 1].clone());
                    j += 2;
                }
                word => {
                    match CString::new(word.as_bytes()) {
                        Ok(cs) => argv.push(cs),
                        Err(_) => return Err("argument contains NUL byte".into()),
                    }
                    j += 1;
                }
            }
        }

        if argv.is_empty() {
            return Err("empty command in pipeline".into());
        }

        stages.push(Stage { argv, in_redir, out_redir });
    }

    Ok((stages, background))
}

/// Built-in `cd` (cd to $HOME if no args).
fn builtin_cd(args: &[&str]) {
    let target: PathBuf = if args.is_empty() {
        match env::var("HOME") {
            Ok(h) => PathBuf::from(h),
            Err(_) => {
                eprintln!("cd: HOME not set");
                return;
            }
        }
    } else {
        PathBuf::from(args[0])
    };
    if let Err(e) = env::set_current_dir(&target) {
        eprintln!("cd: {}: {}", target.display(), e);
    }
}

/// Reap any finished background children.
fn reap_background() {
    loop {
        match waitpid(Pid::from_raw(-1), Some(WaitPidFlag::WNOHANG)) {
            Ok(WaitStatus::Exited(pid, status)) =>
                eprintln!("[vssh] pid {} exited with status {}", pid, status),
            Ok(WaitStatus::Signaled(pid, sig, _)) =>
                eprintln!("[vssh] pid {} terminated by signal {:?}", pid, sig),
            Ok(WaitStatus::StillAlive) => break,
            Ok(_) => break,
            Err(e) => {
                use nix::errno::Errno;
                if e == nix::Error::from(Errno::ECHILD) { break; }
                eprintln!("[vssh] waitpid error: {}", e);
                break;
            }
        }
    }
}

/// Run the pipeline of stages, with optional backgrounding.
fn run_pipeline(stages: &[Stage], background: bool) {
    use nix::libc::{STDIN_FILENO, STDOUT_FILENO};

    let n = stages.len();

    // Prepare N-1 pipes as OwnedFd pairs (nix 0.29)
    let mut pipes: Vec<(OwnedFd, OwnedFd)> = Vec::with_capacity(n.saturating_sub(1));
    for _ in 0..n.saturating_sub(1) {
        match pipe() {
            Ok(p) => pipes.push(p),
            Err(e) => { eprintln!("pipe error: {}", e); return; }
        }
    }

    let mut pids: Vec<Pid> = Vec::with_capacity(n);

    for i in 0..n {
        match unsafe { fork() } {
            Ok(ForkResult::Child) => {
                // ----- stdin wiring -----
                if i == 0 {
                    if let Some(ref infile) = stages[i].in_redir {
                        match File::open(infile) {
                            Ok(f) => {
                                if let Err(e) = dup2(f.as_raw_fd(), STDIN_FILENO) {
                                    eprintln!("dup2(in) error: {}", e);
                                    exit(1);
                                }
                                // f drops here; the dup remains as stdin
                            }
                            Err(e) => {
                                eprintln!("input redirection error '{}': {}", infile, e);
                                exit(1);
                            }
                        }
                    }
                } else {
                    let (ref r, _) = pipes[i - 1];
                    if let Err(e) = dup2(r.as_raw_fd(), STDIN_FILENO) {
                        eprintln!("dup2(pipe in) error: {}", e);
                        exit(1);
                    }
                }

                // ----- stdout wiring -----
                if i == n - 1 {
                    if let Some(ref outfile) = stages[i].out_redir {
                        match File::create(outfile) {
                            Ok(f) => {
                                if let Err(e) = dup2(f.as_raw_fd(), STDOUT_FILENO) {
                                    eprintln!("dup2(out) error: {}", e);
                                    exit(1);
                                }
                                // f drops here; the dup remains as stdout
                            }
                            Err(e) => {
                                eprintln!("output redirection error '{}': {}", outfile, e);
                                exit(1);
                            }
                        }
                    }
                } else {
                    let (_, ref w) = pipes[i];
                    if let Err(e) = dup2(w.as_raw_fd(), STDOUT_FILENO) {
                        eprintln!("dup2(pipe out) error: {}", e);
                        exit(1);
                    }
                }

                // Close all pipe fds in child after dup2
                for (r, w) in &pipes {
                    let _ = close(r.as_raw_fd());
                    let _ = close(w.as_raw_fd());
                }

                // Exec this stage (replaces process on success)
                let argv = &stages[i].argv;
                if let Err(e) = execvp(&argv[0], argv) {
                    eprintln!("execvp error: {}", e);
                    exit(127);
                }
            }
            Ok(ForkResult::Parent { child }) => {
                pids.push(child);
            }
            Err(e) => {
                eprintln!("fork error: {}", e);
                // Parent: drop pipes to close FDs exactly once
                drop(pipes);
                return;
            }
        }
    }

    // Parent closes all pipe fds (drop OwnedFds once)
    drop(pipes);

    if background {
        for pid in pids {
            println!("[vssh] started pid {} in background", pid);
        }
    } else {
        for pid in pids {
            match waitpid(pid, None) {
                Ok(WaitStatus::Exited(_, status)) if status != 0 =>
                    eprintln!("[vssh] process {} exited with status {}", pid, status),
                Ok(WaitStatus::Signaled(_, sig, _)) =>
                    eprintln!("[vssh] process {} killed by signal {:?}", pid, sig),
                Ok(_) => {}
                Err(e) => eprintln!("waitpid error: {}", e),
            }
        }
    }
}

fn main() {
    loop {
        reap_background();
        print_prompt();

        // Read one line
        let mut line = String::new();
        match io::stdin().read_line(&mut line) {
            Ok(0) => { println!(); break; } // EOF
            Ok(_) => {}
            Err(e) => { eprintln!("read error: {}", e); continue; }
        }

        let line = line.trim();
        if line.is_empty() { continue; }
        if line == "exit" { break; }

        // Built-in cd (only as a standalone)
        if line == "cd" || line.starts_with("cd ") {
            let rest = line.strip_prefix("cd").unwrap_or("").trim();
            let args: Vec<&str> = if rest.is_empty() { vec![] } else { vec![rest] };
            builtin_cd(&args);
            continue;
        }

        // Parse and run
        let (stages, background) = match parse_pipeline(line) {
            Ok(x) => x,
            Err(msg) => { eprintln!("parse error: {}", msg); continue; }
        };
        run_pipeline(&stages, background);
    }
}
